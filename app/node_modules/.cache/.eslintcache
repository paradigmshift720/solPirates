[{"C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\index.js":"1","C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\App.js":"2","C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\CandyMachine\\index.js":"3","C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\CandyMachine\\helpers.js":"4","C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\CountdownTimer\\index.js":"5"},{"size":230,"mtime":1639457333998,"results":"6","hashOfConfig":"7"},{"size":2536,"mtime":1639603953583,"results":"8","hashOfConfig":"7"},{"size":11719,"mtime":1639778921365,"results":"9","hashOfConfig":"7"},{"size":529,"mtime":1639457333994,"results":"10","hashOfConfig":"7"},{"size":1677,"mtime":1639608097808,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1reh55e",{"filePath":"15","messages":"16","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19"},{"filePath":"20","messages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"22","messages":"23","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"14"},"C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\index.js",[],["25","26"],"C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\App.js",[],"C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\CandyMachine\\index.js",["27","28"],"import React, { useEffect, useState } from 'react';\r\nimport { Connection, PublicKey } from '@solana/web3.js';\r\nimport { Program, Provider, web3 } from '@project-serum/anchor';\r\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\r\nimport { programs } from '@metaplex/js';\r\nimport './CandyMachine.css';\r\nimport CountdownTimer from '../CountdownTimer';\r\nimport {\r\n  candyMachineProgram,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n} from './helpers';\r\nconst {\r\n  metadata: { Metadata, MetadataProgram },\r\n} = programs;\r\n\r\nconst config = new web3.PublicKey(process.env.REACT_APP_CANDY_MACHINE_CONFIG);\r\nconst { SystemProgram } = web3;\r\nconst opts = {\r\n  preflightCommitment: 'processed',\r\n};\r\n\r\nconst MAX_NAME_LENGTH = 32;\r\nconst MAX_URI_LENGTH = 200;\r\nconst MAX_SYMBOL_LENGTH = 10;\r\nconst MAX_CREATOR_LEN = 32 + 1 + 1;\r\n\r\n\r\n\r\nconst CandyMachine = ({ walletAddress }) => {\r\n  const [machineStats, setMachineStats] = useState(null);\r\n  const [mints, setMints] = useState([]);\r\n  const [isMinting, setIsMinting] = useState(false);\r\n  const [isLoadingMints, setIsLoadingMints] = useState(false);\r\n\r\n  // Actions\r\n  useEffect(() => {\r\n    getCandyMachineState();\r\n  }, []);\r\n\r\n  const getProvider = () => {\r\n    const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\r\n    // Create a new connection object\r\n    const connection = new Connection(rpcHost);\r\n    \r\n    // Create a new Solana provider object\r\n    const provider = new Provider(\r\n      connection,\r\n      window.solana,\r\n      opts.preflightCommitment\r\n    );\r\n  \r\n    return provider;\r\n  };  \r\n\r\n\r\n  // Declare getCandyMachineState as an async method\r\nconst getCandyMachineState = async () => { \r\n  const provider = getProvider();\r\n  // Get metadata about your deployed candy machine program\r\n  const idl = await Program.fetchIdl(candyMachineProgram, provider);\r\n  // Create a program that you can call\r\n  const program = new Program(idl, candyMachineProgram, provider);\r\n  // Fetch the metadata from your candy machine\r\n  const candyMachine = await program.account.candyMachine.fetch(\r\n    process.env.REACT_APP_CANDY_MACHINE_ID\r\n  );\r\n  \r\n  // Parse out all our metadata and log it out\r\n  const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();\r\n  const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();\r\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\r\n  const goLiveData = candyMachine.data.goLiveDate.toNumber();\r\n\r\n  // We will be using this later in our UI so let's generate this now\r\n  const goLiveDateTimeString = `${new Date(\r\n    goLiveData * 1000\r\n  ).toLocaleDateString()} @ ${new Date(\r\n    goLiveData * 1000\r\n  ).toLocaleTimeString()}`;\r\n\r\n  setMachineStats({\r\n    itemsAvailable,\r\n    itemsRedeemed,\r\n    itemsRemaining,\r\n    goLiveData,\r\n    goLiveDateTimeString,\r\n  });\r\n\r\n  console.log({\r\n    itemsAvailable,\r\n    itemsRedeemed,\r\n    itemsRemaining,\r\n    goLiveData,\r\n    goLiveDateTimeString,\r\n  });\r\n\r\n  setIsLoadingMints(true);\r\n\r\n  const data = await fetchHashTable(\r\n    process.env.REACT_APP_CANDY_MACHINE_ID,\r\n    true\r\n  );\r\n  \r\n  if (data.length !== 0) {\r\n    for (const mint of data) {\r\n      // Get URI\r\n      const response = await fetch(mint.data.uri);\r\n      const parse = await response.json();\r\n      console.log(\"Past Minted NFT\", mint)\r\n  \r\n      // Get image URI\r\n      if (!mints.find((mint) => mint === parse.image)) {\r\n        setMints((prevState) => [...prevState, parse.image]);\r\n      }\r\n    }\r\n  }\r\n\r\n  setIsLoadingMints(false);\r\n\r\n};\r\n\r\n  const fetchHashTable = async (hash, metadataEnabled) => {\r\n    const connection = new web3.Connection(\r\n      process.env.REACT_APP_SOLANA_RPC_HOST\r\n    );\r\n\r\n    const metadataAccounts = await MetadataProgram.getProgramAccounts(\r\n      connection,\r\n      {\r\n        filters: [\r\n          {\r\n            memcmp: {\r\n              offset:\r\n                1 +\r\n                32 +\r\n                32 +\r\n                4 +\r\n                MAX_NAME_LENGTH +\r\n                4 +\r\n                MAX_URI_LENGTH +\r\n                4 +\r\n                MAX_SYMBOL_LENGTH +\r\n                2 +\r\n                1 +\r\n                4 +\r\n                0 * MAX_CREATOR_LEN,\r\n              bytes: hash,\r\n            },\r\n          },\r\n        ],\r\n      }\r\n    );\r\n\r\n    const mintHashes = [];\r\n\r\n    for (let index = 0; index < metadataAccounts.length; index++) {\r\n      const account = metadataAccounts[index];\r\n      const accountInfo = await connection.getParsedAccountInfo(account.pubkey);\r\n      const metadata = new Metadata(hash.toString(), accountInfo.value);\r\n      if (metadataEnabled) mintHashes.push(metadata.data);\r\n      else mintHashes.push(metadata.data.mint);\r\n    }\r\n\r\n    return mintHashes;\r\n  };\r\n\r\n  const getMetadata = async (mint) => {\r\n    return (\r\n      await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from('metadata'),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          mint.toBuffer(),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const getMasterEdition = async (mint) => {\r\n    return (\r\n      await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from('metadata'),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          mint.toBuffer(),\r\n          Buffer.from('edition'),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const getTokenWallet = async (wallet, mint) => {\r\n    return (\r\n      await web3.PublicKey.findProgramAddress(\r\n        [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\r\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const mintToken = async () => {\r\n    try {\r\n      setIsMinting(true);\r\n      const mint = web3.Keypair.generate();\r\n      const token = await getTokenWallet(\r\n        walletAddress.publicKey,\r\n        mint.publicKey\r\n      );\r\n      const metadata = await getMetadata(mint.publicKey);\r\n      const masterEdition = await getMasterEdition(mint.publicKey);\r\n      const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\r\n      const connection = new Connection(rpcHost);\r\n      const rent = await connection.getMinimumBalanceForRentExemption(\r\n        MintLayout.span\r\n      );\r\n\r\n      const accounts = {\r\n        config,\r\n        candyMachine: process.env.REACT_APP_CANDY_MACHINE_ID,\r\n        payer: walletAddress.publicKey,\r\n        wallet: process.env.REACT_APP_TREASURY_ADDRESS,\r\n        mint: mint.publicKey,\r\n        metadata,\r\n        masterEdition,\r\n        mintAuthority: walletAddress.publicKey,\r\n        updateAuthority: walletAddress.publicKey,\r\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n        tokenProgram: TOKEN_PROGRAM_ID,\r\n        systemProgram: SystemProgram.programId,\r\n        rent: web3.SYSVAR_RENT_PUBKEY,\r\n        clock: web3.SYSVAR_CLOCK_PUBKEY,\r\n      };\r\n\r\n      const signers = [mint];\r\n      const instructions = [\r\n        web3.SystemProgram.createAccount({\r\n          fromPubkey: walletAddress.publicKey,\r\n          newAccountPubkey: mint.publicKey,\r\n          space: MintLayout.span,\r\n          lamports: rent,\r\n          programId: TOKEN_PROGRAM_ID,\r\n        }),\r\n        Token.createInitMintInstruction(\r\n          TOKEN_PROGRAM_ID,\r\n          mint.publicKey,\r\n          0,\r\n          walletAddress.publicKey,\r\n          walletAddress.publicKey\r\n        ),\r\n        createAssociatedTokenAccountInstruction(\r\n          token,\r\n          walletAddress.publicKey,\r\n          walletAddress.publicKey,\r\n          mint.publicKey\r\n        ),\r\n        Token.createMintToInstruction(\r\n          TOKEN_PROGRAM_ID,\r\n          mint.publicKey,\r\n          token,\r\n          walletAddress.publicKey,\r\n          [],\r\n          1\r\n        ),\r\n      ];\r\n\r\n      const provider = getProvider();\r\n      const idl = await Program.fetchIdl(candyMachineProgram, provider);\r\n      const program = new Program(idl, candyMachineProgram, provider);\r\n\r\n      const txn = await program.rpc.mintNft({\r\n        accounts,\r\n        signers,\r\n        instructions,\r\n      });\r\n\r\n      console.log('txn:', txn);\r\n\r\n      // Setup listener\r\n      connection.onSignatureWithOptions(\r\n        txn,\r\n        async (notification, context) => {\r\n          if (notification.type === 'status') {\r\n            console.log('Receievd status event');\r\n\r\n            const { result } = notification;\r\n            if (!result.err) {\r\n              console.log('NFT Minted!');\r\n              setIsMinting(false);\r\n              await getCandyMachineState();\r\n            }\r\n          }\r\n        },\r\n        { commitment: 'processed' }\r\n      );\r\n    } catch (error) {\r\n      let message = error.msg || 'Minting failed! Please try again!';\r\n      setIsMinting(false);\r\n      if (!error.msg) {\r\n        if (error.message.indexOf('0x138')) {\r\n        } else if (error.message.indexOf('0x137')) {\r\n          message = `SOLD OUT!`;\r\n        } else if (error.message.indexOf('0x135')) {\r\n          message = `Insufficient funds to mint. Please fund your wallet.`;\r\n        }\r\n      } else {\r\n        if (error.code === 311) {\r\n          message = `SOLD OUT!`;\r\n        } else if (error.code === 312) {\r\n          message = `Minting period hasn't started yet.`;\r\n        }\r\n      }\r\n\r\n      console.warn(message);\r\n    }\r\n  };\r\n\r\n  const createAssociatedTokenAccountInstruction = (\r\n    associatedTokenAddress,\r\n    payer,\r\n    walletAddress,\r\n    splTokenMintAddress\r\n  ) => {\r\n    const keys = [\r\n      { pubkey: payer, isSigner: true, isWritable: true },\r\n      { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n      { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n      { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n      {\r\n        pubkey: web3.SystemProgram.programId,\r\n        isSigner: false,\r\n        isWritable: false,\r\n      },\r\n      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n      {\r\n        pubkey: web3.SYSVAR_RENT_PUBKEY,\r\n        isSigner: false,\r\n        isWritable: false,\r\n      },\r\n    ];\r\n    return new web3.TransactionInstruction({\r\n      keys,\r\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n      data: Buffer.from([]),\r\n    });\r\n  };\r\n\r\n  const renderMintedItems = () => (\r\n    <div className=\"gif-container\">\r\n      <p className=\"sub-text\">Minted Items ✨</p>\r\n      <div className=\"gif-grid\">\r\n        {mints.map((mint) => (\r\n          <div className=\"gif-item\" key={mint}>\r\n            <img src={mint} alt={`Minted NFT ${mint}`} />\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n\r\nconst renderDropTimer = () => {\r\n  // Get the current date and dropDate in a JavaScript Date object\r\n  const currentDate = new Date();\r\n  const dropDate = new Date(machineStats.goLiveData * 1000);\r\n\r\n  // If currentDate is before dropDate, render our Countdown component\r\n  if (currentDate < dropDate) {\r\n    return <CountdownTimer dropDate={dropDate} />;\r\n  }\r\n    return <p>{`Drop Date: ${machineStats.goLiveDateTimeString}`}</p>;\r\n  };\r\n\r\n  return (\r\n    machineStats && (\r\n      <div className=\"machine-container\">\r\n        {renderDropTimer()}\r\n        <p>{`Items Minted: ${machineStats.itemsRedeemed} / ${machineStats.itemsAvailable}`}</p>\r\n        {machineStats.itemsRedeemed === machineStats.itemsAvailable ? (\r\n          <p className=\"sub-text\">Sold Out 🙊</p>\r\n        ) : (\r\n          <button\r\n            className=\"cta-button mint-button\"\r\n            onClick={mintToken}\r\n            disabled={isMinting}\r\n          >\r\n            Mint NFT\r\n          </button>\r\n        )}\r\n        {isLoadingMints && <p>LOADING MINTS...</p>}\r\n        {/* {mints.length > 0 && renderMintedItems()} */}\r\n      </div>\r\n    )\r\n  );\r\n};\r\n\r\nexport default CandyMachine;\r\n","C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\CandyMachine\\helpers.js",[],"C:\\Users\\parad\\documents\\nft\\nft-drop-starter-project\\app\\src\\CountdownTimer\\index.js",["29"],"import React, { useEffect, useState } from 'react';\r\nimport './CountdownTimer.css';\r\n\r\nconst CountdownTimer = ({ dropDate }) => {\r\n  // State\r\n  const [timerString, setTimerString] = useState('');\r\n\r\n  // Our useEffect will run on component load\r\nuseEffect(() => {\r\n    console.log('Setting interval...');\r\n  \r\n    // Use setInterval to run this piece of code every second\r\n    const interval = setInterval(() => {\r\n      const currentDate = new Date().getTime();\r\n      const distance = dropDate - currentDate;\r\n  \r\n      // Here it's as easy as doing some time math to get the different properties\r\n      const days = Math.floor(distance / (1000 * 60 * 60 * 24));\r\n      const hours = Math.floor(\r\n        (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)\r\n      );\r\n      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));\r\n      const seconds = Math.floor((distance % (1000 * 60)) / 1000);\r\n  \r\n      // We have our desired output, set it in state!\r\n      setTimerString(`${days}d ${hours}h ${minutes}m ${seconds}s`);\r\n  \r\n      // If our distance passes zero this means that it's drop time!\r\n      if (distance < 0) {\r\n        console.log('Clearing interval...');\r\n        clearInterval(interval);\r\n      }\r\n    }, 1000);\r\n  \r\n    // Anytime our component unmounts let's clean up our interval\r\n    return () => {\r\n      if (interval) {\r\n        clearInterval(interval);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"timer-container\">\r\n      <p className=\"timer-header\">Candy Drop Starting In</p>\r\n      {timerString && <p className=\"timer-value\">{`⏰ ${timerString}`}</p>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CountdownTimer;",{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","severity":1,"message":"35","line":39,"column":6,"nodeType":"36","endLine":39,"endColumn":8,"suggestions":"37"},{"ruleId":"38","severity":1,"message":"39","line":350,"column":9,"nodeType":"40","messageId":"41","endLine":350,"endColumn":26},{"ruleId":"34","severity":1,"message":"42","line":41,"column":6,"nodeType":"36","endLine":41,"endColumn":8,"suggestions":"43"},"no-native-reassign",["44"],"no-negated-in-lhs",["45"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'getCandyMachineState'. Either include it or remove the dependency array.","ArrayExpression",["46"],"no-unused-vars","'renderMintedItems' is assigned a value but never used.","Identifier","unusedVar","React Hook useEffect has a missing dependency: 'dropDate'. Either include it or remove the dependency array.",["47"],"no-global-assign","no-unsafe-negation",{"desc":"48","fix":"49"},{"desc":"50","fix":"51"},"Update the dependencies array to be: [getCandyMachineState]",{"range":"52","text":"53"},"Update the dependencies array to be: [dropDate]",{"range":"54","text":"55"},[1213,1215],"[getCandyMachineState]",[1424,1426],"[dropDate]"]